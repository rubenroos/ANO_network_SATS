---
title: "ANO habitat-species networks"
editor: visual
format:
  html:
    code-fold: true
    code-summary: "Show the code"
---

## Building habitat-species networks using ANO data

Ruben E. Roos, Joachim Töpper

--- Summary coming ---

## Running Code

### Interesting reading material

https://cran.r-project.org/web/packages/bipartite/vignettes/Intro2bipartite.pdf

### For fixing errors when reading Scandinavian letters

https://www.r-bloggers.com/2013/01/r-and-foreign-characters

https://community.rstudio.com/t/possible-bug-non-ascii-characters-not-displayed-properly-in-the-rstudio-release-2021-09-02/126312/2

```{r Adjust to deal with norwegian letters}
#|output: false
#|message: false
#|results: hide
Sys.setlocale(locale='no_NB.utf8')

#knitr::opts_chunk$set()
```

### Load required packages

```{r Load required packages}
#| echo: false
#| message: false
#| warning: false
#| results: hide

#load libraries
library(reshape)
library(vegan)
library(bipartite)
library(tidyverse)
library(randomcoloR)
library(visNetwork)

#Installs the github version (2.19) of bipartite, https://github.com/biometry/bipartite/issues/17
#library(devtools)
#install_github("biometry/bipartite/bipartite")

#Package bipartite needs to be manually installed and updated, can be downloaded here: https://github.com/biometry/bipartite/blob/master/bipartite_2.19.tar.gz, then use tools -> install packages, and tools -> check for package updates
```

### Data import

```{r Import data}
#| echo: false
#| warning: false
#| output: false

#Read and review the data
#ANO.dat <- read.csv("~/Projects/ANO SATS/ANO_network_SATS/Data/ANO.dat.RR.csv", stringsAsFactors=TRUE)
#head(ANO.dat)
#str(ANO.dat)
#names(ANO.dat)
#unique(ANO.dat$ano_flate_id)

ANO.fjell <- read_csv("~/Projects/ANO SATS/ANO_network_SATS/Data/ANO.data.fjell.csv")#silence warning about missing colnames

```

### Some initial data exploration

Before we start our analyses, we can explore the data a bit. In addition, we can calculate some basic metrics and have a look at red-listed species.

```{r Data structure}
#| output: false

unique(ANO.fjell$Species) 
ANO.fjell %>% distinct(Species) %>% arrange(Species)
str(ANO.fjell)
unique(ANO.fjell$ano_flate_id)#list the unique flate IDs

```

We can calculate some general metrics e.g., the average number of species per ANO-punkt, per NiN-type, etc.

NB: there are duplicates in the data set (duplicated species registrations within the same site and entire duplicated sites). For now the duplicated sites are removed entirely, but this is not a durable solution.

```{r Basic data wrangling}
#Calculate and add relative cover per species per ANO plot to the data
ANO.fjell <- ANO.fjell %>% 
  filter(!(art_dekning == 0)) %>% #We should remove the plots where only one species without cover was registered (this is obligatory in the data sampling protocol when no species are present)
  group_by(ano_punkt_id) %>% 
  mutate(dekning_sum = sum(art_dekning, na.rm = TRUE)) %>% 
  mutate(rel_dekning = (art_dekning/dekning_sum))

#We also have one registration of C. bigelowii without any cover, which should be removed
ANO.fjell <- ANO.fjell %>% 
  filter(!is.na(art_dekning))

#Check if there are any duplicates in the data (i.e. same species registered twice per plot)
ANO.fjell %>%
  distinct() %>%
  group_by(ano_punkt_id, Species) %>%
  count() %>% 
  arrange(desc(n)) #Duplicates found!! both duplicated species registration within the same ano_punkt, and duplicated flate_id

#Remove the plots (punkt_id) with duplicated data entirely. To do this, we first make a list, and then filter the data on that list. 
duplicate_list <- as.list(ANO.fjell %>%
  distinct() %>%
  group_by(ano_punkt_id, Species) %>%
  count() %>% 
  filter(n >1))

#Filter the data by the list
ANO.fjell <- ANO.fjell %>% 
  filter(!ano_punkt_id %in% duplicate_list[["ano_punkt_id"]])

# Calculates the most frequently recorded nature type
ANO.fjell %>% 
  count(kartleggingsenhet_1m2) %>% 
  arrange(desc(n))#T3-C-2 (kalkfattig fjell-lynghei) is by far the most common nature type recorded

# Calculates number of species per ANO point
sr <- ANO.fjell %>% 
  group_by(ano_punkt_id) %>% 
  summarise(species_richness = n(), nature_type = first(kartleggingsenhet_1m2))
sr %>% head()

# Calculate average number of species per NiN nature type
sr %>% 
  group_by(nature_type) %>% 
  summarise(mean_sr = mean(species_richness, na.rm=TRUE)) %>% 
  arrange(desc(mean_sr))#orders to view the most species rich nature type first

# Calculate how frequently the redlist categories occur per nature type
habitat.RL <- ANO.fjell %>% 
  select(kartleggingsenhet_1m2, Species, Kategori.2021) %>% 
  mutate(Kategori.2021 = if_else(is.na(Kategori.2021), "IE", Kategori.2021)) %>%   #"NA" is an unfortunately classification to use here, change them to "ikke egnet": "IE"
  group_by(kartleggingsenhet_1m2) %>% 
  distinct(Species, .keep_all = TRUE) %>% #creates a species list per NiN nature type and their redlist status
  summarise("Number of species" = n(),
    across(Kategori.2021, list(IE = ~ sum(. == "IE"),
                                LC = ~ sum(. == "LC"),
                                DD = ~ sum(. == "DD"),
                                NT = ~ sum(. == "NT"), 
                                VU = ~ sum(. == "VU"),
                                EN = ~ sum(. == "EN"),
                                CR = ~ sum(. == "CR"),
                                RE = ~ sum(. == "RE")))) %>% 
  rowwise() %>% 
  mutate(RL = sum(Kategori.2021_DD, Kategori.2021_NT, Kategori.2021_VU, 
                    Kategori.2021_EN, Kategori.2021_CR, Kategori.2021_RE), 
         TS = sum(Kategori.2021_VU, Kategori.2021_EN, Kategori.2021_CR)) %>% #add number of readlisted species (DD-RE), and threatened species (VU, EN, CR)
  arrange(desc(RL))#order nature types by most redlisted species: T27-C-6 (kalkfattig og intermediaer rabbepreget blokkmark) has most RL species

#Calculate community weighted value for cold requirement per ANOplot
ANO.fjell %>% 
  group_by(ano_punkt_id) %>% 
  summarise(cwm_cold_requirement = weighted.mean(Cold_requirement, rel_dekning, na.rm = TRUE))

#Calculate community weighted value or cold requirement per NiN nature type
#Ruben: not sure if this is the best way to do it?
habitat.cwm.cold<- ANO.fjell %>% 
  group_by(kartleggingsenhet_1m2) %>% 
  summarise(cwm_cold_requirement = weighted.mean(Cold_requirement, rel_dekning, na.rm = TRUE)) %>% 
  arrange(desc(cwm_cold_requirement))

#This gives the exact same result:
ANO.fjell %>% 
  group_by(ano_punkt_id, kartleggingsenhet_1m2) %>% 
  summarise(cwm_cold_requirement = weighted.mean(Cold_requirement, rel_dekning, na.rm = TRUE)) %>% 
  group_by(kartleggingsenhet_1m2) %>% 
  summarise(mean_cwm_cold_requirement = mean(cwm_cold_requirement, na.rm = TRUE)) %>% arrange(desc(mean_cwm_cold_requirement))
  

```

We can expect a correlation between the number of redlisted species and the cold requirements, because many mountain species are redlisted due to climate change.

```{r Redlist vs cold requirements}

#combine data
RL.cold <- habitat.RL %>% 
  left_join(habitat.cwm.cold, by = "kartleggingsenhet_1m2")

RL.cold %>% 
  ggplot(aes(x = cwm_cold_requirement, y = RL)) +
  geom_point()

```

### Building network models

#### Preparing data for analyses

For building network models, we want a data file that contains all the "kartleggingsenheter" across the data set, their species, and the cumulative abundance of all individual species. This is also a nice opportunity to rename the ANO-specific terms into terms that are more understandable to the average reader. We will refer to "Flate" as Site, "Punkt" as Plot, "Kartleggingsenhet_1m2" will be refered to as Nature type, registered at each Plot. At each Plot, all plant species and their cover are recorded.

```{r Create data set for network analyses}

#Update the column names, this code will keep all the individual plots and their recorded nature types and species. The code below will summarize per Site. 
ANO.cover <- ANO.fjell %>% 
   select(ano_flate_id, ano_punkt_id, kartleggingsenhet_1m2, Species, art_dekning) %>%  
  rename(Habitat_type = kartleggingsenhet_1m2, 
         Species_cover = art_dekning, 
         Site = ano_flate_id, 
         Plot = ano_punkt_id)#more user-friendly colnames

#calculate species cover per naturype per Site (using sum)
ANO.cover.sum <- ANO.fjell %>% 
   select(ano_flate_id, ano_punkt_id, kartleggingsenhet_1m2, Species, art_dekning) %>% 
  group_by(ano_flate_id, kartleggingsenhet_1m2, Species) %>% 
  summarize(cover_sum = sum(art_dekning)) %>% 
  rename(Habitat_type = kartleggingsenhet_1m2, 
         Species_cover_summed = cover_sum, 
         Site = ano_flate_id)#more user-friendly colnames

#Convert to wide format
ANO.cover <- ANO.cover %>% 
  pivot_wider(names_from = Species, values_from = Species_cover, values_fill = 0) %>% rename(Nature_type = Habitat_type)
ANO.cover.sum <- ANO.cover.sum %>% pivot_wider(names_from = Species, values_from = Species_cover_summed, values_fill = 0) %>% rename(Nature_type = Habitat_type)

# Create a dataset that calculates the most frequent nin type per Flate
ANO.type <- ANO.fjell %>% 
    select(ano_flate_id, ano_punkt_id, kartleggingsenhet_1m2) %>% 
  group_by(ano_punkt_id, ano_flate_id) %>% 
  summarise(kartleggingsenhet_1m2 = first(kartleggingsenhet_1m2)) %>%
  group_by(ano_flate_id) %>% 
  summarise(Common_nature_type = names(which.max(table(kartleggingsenhet_1m2)))) %>% 
  rename(Site= ano_flate_id)

#Join these two data frames
ANO.cover <- ANO.cover %>% 
  left_join(ANO.type, by = "Site") 

#Creates a patch dataframe to store its properties. Assigns a unique color to each nature type in the dataset. 
Nature.types <- unique(ANO.cover[, c("Plot", "Nature_type")])
Nature.types <- Nature.types %>% 
  dplyr::group_by(Nature_type) %>% 
  dplyr::mutate(Color = randomcoloR::randomColor()) %>%
  dplyr::ungroup()
```

#### Worked example for one site

First, let's visualize the network

```{r Worked example for one site}

#For a proof of concept, let's select one random Site and create a network for it. 
df <- ANO.cover %>% 
  filter(Site == "ANO1517")

#Remove all columns (species) that sum to zero and are not recorded at the site
df <- df %>% 
   select(where(~ is.numeric(.) && sum(., na.rm = TRUE) > 0))

#Create a matrix
ntw.ANO <- as.matrix(df[2:28]) #assign columns included manually
rownames(ntw.ANO)<- df$Plot

#We can use package _bipartite_ to plot the network:
legend <- unique(Nature.types[,c("Nature_type", "Color")])#prepare legend
par(xpd = T) #allow plotting outside the plot
plotweb(ntw.ANO, col.low = as.character(Nature.types$Color))
legend(x=0, y=0.25, as.character(legend$Nature_type), pch=21,
       col="#777777", pt.bg=as.character(legend$Color), 
       pt.cex=1, cex=.6, bty="n", ncol=2)
visweb(ntw.ANO, prednames = T, preynames = T, labsize = 0.6)

#See also: https://briatte.github.io/ggnet/






```

Now we can examine how the network is structured, for example by calculating nestedness. Here, we use weighted NODF, one of the more popular and robust nestedness metrics (Almeida-Neto et al. 2008, Almeida-Neto et al. 2010), but other options are also available.

```{r Calculating Nestedness/NODF}

(obs <- networklevel(web = ntw.ANO, index = "weighted NODF"))


```

To know if `r obs` is more nested than expected by chance for this network, we need to compare it with a null model:

```{r Nestedness vs null, message=FALSE, warning=FALSE}
nm <- nullmodel(web = ntw.ANO, N=100, method="vaznull")
null <- unlist(sapply(nm, networklevel, index="weighted NODF")) 
plot(density(null), xlim=c(min(obs, min(null)), max(obs, max(null))), 
		main="comparison of observed with null model Patefield")
abline(v=obs, col="red", lwd=2)    
praw <- sum(null>obs) / length(null)

```

Here, we can see that this network is less nested than expected by chance (p value `r ifelse(praw > 0.5, round(1-praw,3), round(praw, 3))`)). This suggests that these species do not use habitats in a nested way (i.e. species-rich habitats do not host species found in species poor habitats) and we should check for other network structural features.

To gain further insights on the structure of species habitats networks, we can use another important structural metric: modularity. In this example, we will calculate a quantitative version of the metric (Dormann et al., 2014).

For info on this: Detecting modules in quantitative bipartite networks: the QuaBiMo algorithm -- arXiv Vanity (arxiv-vanity.com)

```{r Module figure}
#| fig.height: "160%"

res <- metaComputeModules(ntw.ANO, N = 5)
plotModuleWeb(res, displayAlabels = TRUE, displayBlabels = TRUE)

```

```{r Modularity}
#listModuleInformation(res)
#printoutModuleInformation(res)
modules.nulls <- sapply(nm, computeModules)
like.nulls <- sapply(modules.nulls, function(x) x@likelihood)
praw <- sum(like.nulls > res@likelihood) / length(like.nulls)
```

The network is more modular than expected by chance (p-value \< `r ifelse(praw > 0.5, round(1-praw,3), round(praw, 3))`). This confirms that each habitat tends to harbour a quite unique assemblage of species, with limited exchange between habitat patches. The modules identified here do not immediately cluster true to the nature type they were assigned.

```{r cz values}
#we can calculate 2 values for each node
cz <- czvalues(res, weighted = TRUE, level = "lower")
#c : among-module connectivity
#z : within-module connectivity
#Olesen et al. (2006) give critical c and z values of 0.62 and 2.6, respectively. Species exceeding these values are deemed connectors or hubs of a network. The justification of these thresholds remains unclear to me. They may also not apply for the quantitative version.
plot(cz[[1]], cz[[2]], pch=16, xlab="c", ylab="z", 
     cex=0.8, las=1, col = Nature.types$Color)
text(cz[[1]], cz[[2]], names(cz[[1]]), pos=4, cex=0.7)


#What does this mean?
```

Next, we can ask which habitat patches (nature types would we prioritize for its conservation value. For this we can calculate its strength (Bascopmte et al 2006). We can use the "specieslevel" function to calculate a lot of other parameters for each species and nature type. Use "networklevel" to calculate parameters for the whole network

```{r}
#we transpose the matrix to calculate it for the lower level.
#Cons.val$strength <- bipartite::strength(ntw.ANO, type="Bascompte")#doesn't work because not all nature types are included
#Cons.val

bipartite::strength(t(ntw.ANO))#produces NaN for strength??

bipartite::strength(ntw.ANO, type="Bascompte")

#check many more parameters by species/Nature type
specieslevel(ntw.ANO, level = "lower")

#Check many parameters for the whole network
networklevel(ntw.ANO)

```

#### Removing species and habitats

To test the robustness of the network, we can remove species (or habitats). Robustness is defined as the area beneath the extinction curve. Extinctions can be random, based on abundance or connectedness (method = degree, very extreme case with common, well-connected species going first). A custom list e.g., based on redlist status can also be provided.

```{r Calculating robustness}
ntw.ext.rand <- second.extinct(web = ntw.ANO, nrep = 100, participant = "higher", method = "random", details = FALSE) #random removal of species

ntw.ext.abun <- second.extinct(web = ntw.ANO, nrep = 50, participant = "higher", method = "abundance", details = FALSE) #removing the least abundant species first

ntw.ext.degr <- second.extinct(web = ntw.ANO, nrep = 50, participant = "higher", method = "degree", details = FALSE) #removing the most connected species first


ntw.ext.habitat.rand <- second.extinct(web = ntw.ANO, nrep = 100, participant = "lower", method = "random", details = FALSE)#random removal of nature types

ntw.ext.habitat.abun <- second.extinct(web = ntw.ANO, nrep = 100, participant = "lower", method = "abundance", details = FALSE) #random removal of nature types based on abundance (least first)

ntw.ext.habitat.degr <- second.extinct(web = ntw.ANO, nrep = 100, participant = "lower", method = "degree", details = FALSE) #random removal of nature types based on connections (most first)

#Calculate robustness (surface area underneath the extinction curve)
robustness(second.extinct(web = ntw.ANO, nrep = 50, participant = "lower", method = "abundance", details = TRUE))
```

Plot the extinction curve

```{r Plotting extinction curves}
slope.bipartite(ntw.ext.rand, plot.it = TRUE)
slope.bipartite(ntw.ext.abun, plot.it = TRUE)
slope.bipartite(ntw.ext.degr, plot.it = TRUE)
slope.bipartite(ntw.ext.habitat.rand, plot.it = TRUE)
slope.bipartite(ntw.ext.habitat.abun, plot.it = TRUE)
slope.bipartite(ntw.ext.habitat.degr, plot.it = TRUE)
```

#### One network for the entire dataset

An alternative approach is to create one network for the entire dataset. In this case, we can calculate and average cover for each species for each nature type, and then create one network.

```{r Dataset for one general network}

#Create dataset with summed cover for each species per nature type
ANO.cover.total <- ANO.cover %>% 
  pivot_longer(!c(Site, Plot, Nature_type, Common_nature_type), names_to = "Species", values_to = "Species_cover") %>% #convert to long format
  group_by(Nature_type, Species) %>% 
  summarize(Species_cover_sum = sum(Species_cover)) %>% 
  pivot_wider(names_from = Species, values_from = Species_cover_sum, values_fill = 0) #convert back to wide
  
#Convert to matrix for network model

ntw.ANO.summed <- as.matrix(ANO.cover.total[2:362]) #assign columns included manually
rownames(ntw.ANO.summed)<- ANO.cover.total$Nature_type

#We can use package _bipartite_ to plot the network:
legend <- unique(Nature.types[,c("Nature_type", "Color")])#prepare legend
par(xpd = T) #allow plotting outside the plot
plotweb(ntw.ANO.summed, col.low = as.character(Nature.types$Color))
legend(x=0, y=0.25, as.character(legend$Nature_type), pch=21,
       col="#777777", pt.bg=as.character(legend$Color), 
       pt.cex=1, cex=.6, bty="n", ncol=2)
#visweb(ntw.ANO.summed, prednames = T, preynames = T, labsize = 0.6)

#Make some extinction curves for this network 
ntw.rand <- second.extinct(web = ntw.ANO.summed, nrep = 100, participant = "higher", method = "random", details = FALSE) #random removal of species

ntw.abun <- second.extinct(web = ntw.ANO.summed, nrep = 50, participant = "higher", method = "abundance", details = FALSE) #removing the least abundant species first

ntw.degr <- second.extinct(web = ntw.ANO.summed, nrep = 50, participant = "higher", method = "degree", details = FALSE) #removing the most connected species first

#Plot these
slope.bipartite(ntw.rand, plot.it = TRUE)
slope.bipartite(ntw.abun, plot.it = TRUE)
slope.bipartite(ntw.degr, plot.it = TRUE)

ntw.habitat.rand <- second.extinct(web = ntw.ANO.summed, nrep = 100, participant = "lower", method = "random", details = FALSE)#random removal of nature types

ntw.habitat.abun <- second.extinct(web = ntw.ANO.summed, nrep = 100, participant = "lower", method = "abundance", details = FALSE) #random removal of nature types based on abundance (least first)

ntw.habitat.degr <- second.extinct(web = ntw.ANO.summed, nrep = 100, participant = "lower", method = "degree", details = FALSE) #random removal of nature types based on connections (most first)

#Plot these
slope.bipartite(ntw.habitat.rand, plot.it = TRUE)
slope.bipartite(ntw.habitat.abun, plot.it = TRUE)
slope.bipartite(ntw.habitat.degr, plot.it = TRUE)

```
