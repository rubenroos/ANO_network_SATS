---
title: "ANO habitat-species networks"
editor: visual
format:
  html:
    code-fold: true
    code-summary: "Show the code"
---

## Building habitat-species networks using ANO data

Ruben E. Roos, Joachim TÃ¶pper

--- Summary coming ---

## Running Code

### Interesting reading material

https://cran.r-project.org/web/packages/bipartite/vignettes/Intro2bipartite.pdf

### For fixing errors when reading Scandinavian letters

https://www.r-bloggers.com/2013/01/r-and-foreign-characters

https://community.rstudio.com/t/possible-bug-non-ascii-characters-not-displayed-properly-in-the-rstudio-release-2021-09-02/126312/2

```{r Adjust to deal with norwegian letters}
#|output: false
#|message: false
#|results: hide
Sys.setlocale(locale='no_NB.utf8')

#knitr::opts_chunk$set()
```

### Load required packages

```{r Load required packages}
#| echo: false
#| message: false
#| warning: false
#| results: hide

#load libraries
library(reshape)
library(vegan)
library(bipartite)
library(tidyverse)
library(randomcoloR)
library(visNetwork)

#Installs the github version (2.19) of bipartite, https://github.com/biometry/bipartite/issues/17
#library(devtools)
#install_github("biometry/bipartite/bipartite")

#Package bipartite needs to be manually installed and updated, can be downloaded here: https://github.com/biometry/bipartite/blob/master/bipartite_2.19.tar.gz, then use tools -> install packages, and tools -> check for package updates
```

### Data import

```{r Import data}
#| echo: false
#| warning: false
#| output: false

#Read and review the data
#ANO.dat <- read.csv("~/Projects/ANO SATS/ANO_network_SATS/Data/ANO.dat.RR.csv", stringsAsFactors=TRUE)
#head(ANO.dat)
#str(ANO.dat)
#names(ANO.dat)
#unique(ANO.dat$ano_flate_id)

ANO.fjell <- read_csv("~/Projects/ANO SATS/ANO_network_SATS/Data/ANO.data.fjell.csv")#silence warning about missing colnames

```

### Some initial data exploration

Before we start our analyses, we can explore the data a bit. In addition, we can calculate some basic metrics and have a look at red-listed species.

```{r Data structure}
#| output: false

unique(ANO.fjell$Species) 
ANO.fjell %>% distinct(Species) %>% arrange(Species)
str(ANO.fjell)
unique(ANO.fjell$ano_flate_id)#list the unique flate IDs

```

We can calculate some general metrics e.g., the average number of species per ANO-punkt, per NiN-type, etc.

NB: there are duplicates in the data set (duplicated species registrations within the same site and entire duplicated sites). For now the duplicated sites are removed entirely, but this is not a durable solution.

```{r Basic data wrangling}
#Calculate and add relative cover per species per ANO plot to the data
ANO.fjell <- ANO.fjell %>% 
  filter(!(art_dekning == 0)) %>% #We should remove the plots where only one species without cover was registered (this is obligatory in the data sampling protocol when no species are present)
  group_by(ano_punkt_id) %>% 
  mutate(dekning_sum = sum(art_dekning, na.rm = TRUE)) %>% 
  mutate(rel_dekning = (art_dekning/dekning_sum))

#We also have one registration of C. bigelowii without any cover, which should be removed
ANO.fjell <- ANO.fjell %>% 
  filter(!is.na(art_dekning))

#Check if there are any duplicates in the data (i.e. same species registered twice per plot)
ANO.fjell %>%
  distinct() %>%
  group_by(ano_punkt_id, Species) %>%
  count() %>% 
  arrange(desc(n)) #Duplicates found!! both duplicated species registration within the same ano_punkt, and duplicated flate_id

#Remove the plots (punkt_id) with duplicated data entirely. To do this, we first make a list, and then filter the data on that list. 
duplicate_list <- as.list(ANO.fjell %>%
  distinct() %>%
  group_by(ano_punkt_id, Species) %>%
  count() %>% 
  filter(n >1))

#Filter the data by the list
ANO.fjell <- ANO.fjell %>% 
  filter(!ano_punkt_id %in% duplicate_list[["ano_punkt_id"]])

# Calculates the most frequently recorded nature type
ANO.fjell %>% 
  count(kartleggingsenhet_1m2) %>% 
  arrange(desc(n))#T3-C-2 (kalkfattig fjell-lynghei) is by far the most common nature type recorded

# Calculates number of species per ANO point
sr <- ANO.fjell %>% 
  group_by(ano_punkt_id) %>% 
  summarise(species_richness = n(), nature_type = first(kartleggingsenhet_1m2))
sr %>% head()

# Calculate average number of species per NiN nature type
sr %>% 
  group_by(nature_type) %>% 
  summarise(mean_sr = mean(species_richness, na.rm=TRUE)) %>% 
  arrange(desc(mean_sr))#orders to view the most species rich nature type first

# Calculate how frequently the redlist categories occur per nature type
habitat.RL <- ANO.fjell %>% 
  select(kartleggingsenhet_1m2, Species, Kategori.2021) %>% 
  mutate(Kategori.2021 = if_else(is.na(Kategori.2021), "IE", Kategori.2021)) %>%   #"NA" is an unfortunately classification to use here, change them to "ikke egnet": "IE"
  group_by(kartleggingsenhet_1m2) %>% 
  distinct(Species, .keep_all = TRUE) %>% #creates a species list per NiN nature type and their redlist status
  summarise("Number of species" = n(),
    across(Kategori.2021, list(IE = ~ sum(. == "IE"),
                                LC = ~ sum(. == "LC"),
                                DD = ~ sum(. == "DD"),
                                NT = ~ sum(. == "NT"), 
                                VU = ~ sum(. == "VU"),
                                EN = ~ sum(. == "EN"),
                                CR = ~ sum(. == "CR"),
                                RE = ~ sum(. == "RE")))) %>% 
  rowwise() %>% 
  mutate(RL = sum(Kategori.2021_DD, Kategori.2021_NT, Kategori.2021_VU, 
                    Kategori.2021_EN, Kategori.2021_CR, Kategori.2021_RE), 
         TS = sum(Kategori.2021_VU, Kategori.2021_EN, Kategori.2021_CR)) %>% #add number of readlisted species (DD-RE), and threatened species (VU, EN, CR)
  arrange(desc(RL))#order nature types by most redlisted species: T27-C-6 (kalkfattig og intermediaer rabbepreget blokkmark) has most RL species

#Calculate community weighted value for cold requirement per ANOplot
ANO.fjell %>% 
  group_by(ano_punkt_id) %>% 
  summarise(cwm_cold_requirement = weighted.mean(Cold_requirement, rel_dekning, na.rm = TRUE))

#Calculate community weighted value or cold requirement per NiN nature type
#Ruben: not sure if this is the best way to do it?
habitat.cwm.cold<- ANO.fjell %>% 
  group_by(kartleggingsenhet_1m2) %>% 
  summarise(cwm_cold_requirement = weighted.mean(Cold_requirement, rel_dekning, na.rm = TRUE)) %>% 
  arrange(desc(cwm_cold_requirement))

#This gives the exact same result:
ANO.fjell %>% 
  group_by(ano_punkt_id, kartleggingsenhet_1m2) %>% 
  summarise(cwm_cold_requirement = weighted.mean(Cold_requirement, rel_dekning, na.rm = TRUE)) %>% 
  group_by(kartleggingsenhet_1m2) %>% 
  summarise(mean_cwm_cold_requirement = mean(cwm_cold_requirement, na.rm = TRUE)) %>% arrange(desc(mean_cwm_cold_requirement))
  

```

We can expect a correlation between the number of redlisted species and the cold requirements, because many mountain species are redlisted due to climate change.

```{r Redlist vs cold requirements}

#combine data
RL.cold <- habitat.RL %>% 
  left_join(habitat.cwm.cold, by = "kartleggingsenhet_1m2")

RL.cold %>% 
  ggplot(aes(x = cwm_cold_requirement, y = RL)) +
  geom_point()

```

### Building network models

#### Preparing data for analyses

For building network models, we want a data file that contains all the "kartleggingsenheter" across the data set, their species, and the cumulative abundance of all individual species. This is also a nice opportunity to rename the ANO-specific terms into terms that are more understandable to the average reader. We will refer to "Flate" as Site, "Punkt" as Plot, "Kartleggingsenhet_1m2" will be refered to as Nature type, registered at each Plot. At each Plot, all plant species and their cover are recorded.

```{r Create data set for network analyses}

#Update the column names, this code will keep all the individual plots and their recorded nature types and species. The code below will summarize per Site. 
ANO.cover <- ANO.fjell %>% 
   select(ano_flate_id, ano_punkt_id, kartleggingsenhet_1m2, Species, art_dekning) %>%  
  rename(Habitat_type = kartleggingsenhet_1m2, 
         Species_cover = art_dekning, 
         Site = ano_flate_id, 
         Plot = ano_punkt_id)#more user-friendly colnames

#calculate species cover per naturype per Site (using sum)
ANO.cover.sum <- ANO.fjell %>% 
   select(ano_flate_id, ano_punkt_id, kartleggingsenhet_1m2, Species, art_dekning) %>% 
  group_by(ano_flate_id, kartleggingsenhet_1m2, Species) %>% 
  summarize(cover_sum = sum(art_dekning)) %>% 
  rename(Habitat_type = kartleggingsenhet_1m2, 
         Species_cover_summed = cover_sum, 
         Site = ano_flate_id)#more user-friendly colnames

#Convert to wide format
ANO.cover <- ANO.cover %>% 
  pivot_wider(names_from = Species, values_from = Species_cover, values_fill = 0) %>% rename(Nature_type = Habitat_type)
ANO.cover.sum <- ANO.cover.sum %>% pivot_wider(names_from = Species, values_from = Species_cover_summed, values_fill = 0) %>% rename(Nature_type = Habitat_type)

# Create a dataset that calculates the most frequent nin type per Flate
ANO.type <- ANO.fjell %>% 
    select(ano_flate_id, ano_punkt_id, kartleggingsenhet_1m2) %>% 
  group_by(ano_punkt_id, ano_flate_id) %>% 
  summarise(kartleggingsenhet_1m2 = first(kartleggingsenhet_1m2)) %>%
  group_by(ano_flate_id) %>% 
  summarise(Common_nature_type = names(which.max(table(kartleggingsenhet_1m2)))) %>% 
  rename(Site= ano_flate_id)

#Join these two data frames
ANO.cover <- ANO.cover %>% 
  left_join(ANO.type, by = "Site") 

#Creates a patch dataframe to store its properties. Assigns a unique color to each nature type in the dataset. 
Nature.types <- unique(ANO.cover[, c("Plot", "Nature_type")])
Nature.types <- Nature.types %>% 
  dplyr::group_by(Nature_type) %>% 
  dplyr::mutate(Color = randomcoloR::randomColor()) %>%
  dplyr::ungroup()
```

#### Worked example for one site

First, let's visualize the network

```{r Worked example for one site}

#For a proof of concept, let's select one random Site and create a network for it. 
df <- ANO.cover %>% 
  filter(Site == "ANO1517")

#Remove all columns (species) that sum to zero and are not recorded at the site
df <- df %>% 
   select(where(~ is.numeric(.) && sum(., na.rm = TRUE) > 0))

#Create a matrix
ntw.ANO <- as.matrix(df[2:28]) #assign columns included manually
rownames(ntw.ANO)<- df$Plot

#We can use package _bipartite_ to plot the network:
legend <- unique(Nature.types[,c("Nature_type", "Color")])#prepare legend
par(xpd = T) #allow plotting outside the plot
plotweb(ntw.ANO, col.low = as.character(Nature.types$Color))
legend(x=0, y=0.25, as.character(legend$Nature_type), pch=21,
       col="#777777", pt.bg=as.character(legend$Color), 
       pt.cex=1, cex=.6, bty="n", ncol=2)
visweb(ntw.ANO, prednames = T, preynames = T, labsize = 0.6)

#See also: https://briatte.github.io/ggnet/






```

Now we can examine how the network is structured, for example by calculating nestedness. Here, we use weighted NODF, one of the more popular and robust nestedness metrics (Almeida-Neto et al. 2008, Almeida-Neto et al. 2010), but other options are also available.

```{r Calculating Nestedness/NODF}

(obs <- networklevel(web = ntw.ANO, index = "weighted NODF"))


```

To know if `r obs` is more nested than expected by chance for this network, we need to compare it with a null model:

```{r Nestedness vs null, message=FALSE, warning=FALSE}
nm <- nullmodel(web = ntw.ANO, N=100, method="vaznull")
null <- unlist(sapply(nm, networklevel, index="weighted NODF")) 
plot(density(null), xlim=c(min(obs, min(null)), max(obs, max(null))), 
		main="comparison of observed with null model Patefield")
abline(v=obs, col="red", lwd=2)    
praw <- sum(null>obs) / length(null)

```

Here, we can see that this network is less nested than expected by chance (p value `r ifelse(praw > 0.5, round(1-praw,3), round(praw, 3))`)). This suggests that these species do not use habitats in a nested way (i.e. species-rich habitats do not host species found in species poor habitats) and we should check for other network structural features.

To gain further insights on the structure of species habitats networks, we can use another important structural metric: modularity. In this example, we will calculate a quantitative version of the metric (Dormann et al., 2014).

For info on this: Detecting modules in quantitative bipartite networks: the QuaBiMo algorithm --Â arXiv Vanity (arxiv-vanity.com)

```{r Module figure}
#| fig.height: "160%"

res <- metaComputeModules(ntw.ANO, N = 5)
plotModuleWeb(res, displayAlabels = TRUE, displayBlabels = TRUE)

```

```{r Modularity}
#listModuleInformation(res)
#printoutModuleInformation(res)
modules.nulls <- sapply(nm, computeModules)
like.nulls <- sapply(modules.nulls, function(x) x@likelihood)
praw <- sum(like.nulls > res@likelihood) / length(like.nulls)
```

The network is more modular than expected by chance (p-value \< `r ifelse(praw > 0.5, round(1-praw,3), round(praw, 3))`). This confirms that each habitat tends to harbour a quite unique assemblage of species, with limited exchange between habitat patches. The modules identified here do not immediately cluster true to the nature type they were assigned.

```{r cz values}
#we can calculate 2 values for each node
cz <- czvalues(res, weighted = TRUE, level = "lower")
#c : among-module connectivity
#z : within-module connectivity
#Olesen et al. (2006) give critical c and z values of 0.62 and 2.6, respectively. Species exceeding these values are deemed connectors or hubs of a network. The justification of these thresholds remains unclear to me. They may also not apply for the quantitative version.
plot(cz[[1]], cz[[2]], pch=16, xlab="c", ylab="z", 
     cex=0.8, las=1, col = Nature.types$Color)
text(cz[[1]], cz[[2]], names(cz[[1]]), pos=4, cex=0.7)


#What does this mean?
```

Next, we can ask which habitat patches (nature types would we prioritize for its conservation value. For this we can calculate its strength (Bascopmte et al 2006). We can use the "specieslevel" function to calculate a lot of other parameters for each species and nature type. Use "networklevel" to calculate parameters for the whole network

```{r}
#we transpose the matrix to calculate it for the lower level.
#Cons.val$strength <- bipartite::strength(ntw.ANO, type="Bascompte")#doesn't work because not all nature types are included
#Cons.val

bipartite::strength(t(ntw.ANO))#produces NaN for strength??

bipartite::strength(ntw.ANO, type="Bascompte")

#check many more parameters by species/Nature type
specieslevel(ntw.ANO, level = "lower")

#Check many parameters for the whole network
networklevel(ntw.ANO)

```

#### Removing species and habitats

To test the robustness of the network, we can remove species (or habitats). Robustness is defined as the area beneath the extinction curve. Extinctions can be random, based on abundance or connectedness (method = degree, very extreme case with common, well-connected species going first). A custom list e.g., based on redlist status can also be provided.

```{r Calculating robustness}
ntw.ext.rand <- second.extinct(web = ntw.ANO, nrep = 100, participant = "higher", method = "random", details = FALSE) #random removal of species

ntw.ext.abun <- second.extinct(web = ntw.ANO, nrep = 50, participant = "higher", method = "abundance", details = FALSE) #removing the least abundant species first

ntw.ext.degr <- second.extinct(web = ntw.ANO, nrep = 50, participant = "higher", method = "degree", details = FALSE) #removing the most connected species first


ntw.ext.habitat.rand <- second.extinct(web = ntw.ANO, nrep = 100, participant = "lower", method = "random", details = FALSE)#random removal of nature types

ntw.ext.habitat.abun <- second.extinct(web = ntw.ANO, nrep = 100, participant = "lower", method = "abundance", details = FALSE) #random removal of nature types based on abundance (least first)

ntw.ext.habitat.degr <- second.extinct(web = ntw.ANO, nrep = 100, participant = "lower", method = "degree", details = FALSE) #random removal of nature types based on connections (most first)

#Calculate robustness (surface area underneath the extinction curve)
robustness(second.extinct(web = ntw.ANO, nrep = 50, participant = "lower", method = "abundance", details = TRUE))
```

Plot the extinction curve

```{r Plotting extinction curves}
slope.bipartite(ntw.ext.rand, plot.it = TRUE)
slope.bipartite(ntw.ext.abun, plot.it = TRUE)
slope.bipartite(ntw.ext.degr, plot.it = TRUE)
slope.bipartite(ntw.ext.habitat.rand, plot.it = TRUE)
slope.bipartite(ntw.ext.habitat.abun, plot.it = TRUE)
slope.bipartite(ntw.ext.habitat.degr, plot.it = TRUE)
```

#### One network for the entire dataset

An alternative approach is to create one network for the entire dataset. In this case, we can calculate and average cover for each species for each nature type, and then create one network.

```{r Dataset for one general network}

#Create dataset with summed cover for each species per nature type
ANO.cover.total <- ANO.cover %>% 
  pivot_longer(!c(Site, Plot, Nature_type, Common_nature_type), names_to = "Species", values_to = "Species_cover") %>% #convert to long format
  group_by(Nature_type, Species) %>% 
  summarize(Species_cover_sum = sum(Species_cover)) %>% 
  pivot_wider(names_from = Species, values_from = Species_cover_sum, values_fill = 0) #convert back to wide
  
#Convert to matrix for network model

ntw.ANO.summed <- as.matrix(ANO.cover.total[2:362]) #assign columns included manually
rownames(ntw.ANO.summed)<- ANO.cover.total$Nature_type

#We can use package _bipartite_ to plot the network:
legend <- unique(Nature.types[,c("Nature_type", "Color")])#prepare legend
par(xpd = T) #allow plotting outside the plot
plotweb(ntw.ANO.summed, col.low = as.character(Nature.types$Color))
legend(x=0, y=0.25, as.character(legend$Nature_type), pch=21,
       col="#777777", pt.bg=as.character(legend$Color), 
       pt.cex=1, cex=.6, bty="n", ncol=2)
#visweb(ntw.ANO.summed, prednames = T, preynames = T, labsize = 0.6)

#Make some extinction curves for this network 
ntw.rand <- second.extinct(web = ntw.ANO.summed, nrep = 100, participant = "higher", method = "random", details = FALSE) #random removal of species

ntw.abun <- second.extinct(web = ntw.ANO.summed, nrep = 50, participant = "higher", method = "abundance", details = FALSE) #removing the least abundant species first

ntw.degr <- second.extinct(web = ntw.ANO.summed, nrep = 50, participant = "higher", method = "degree", details = FALSE) #removing the most connected species first

#Plot these
slope.bipartite(ntw.rand, plot.it = TRUE)
slope.bipartite(ntw.abun, plot.it = TRUE)
slope.bipartite(ntw.degr, plot.it = TRUE)

ntw.habitat.rand <- second.extinct(web = ntw.ANO.summed, nrep = 100, participant = "lower", method = "random", details = FALSE)#random removal of nature types

ntw.habitat.abun <- second.extinct(web = ntw.ANO.summed, nrep = 100, participant = "lower", method = "abundance", details = FALSE) #random removal of nature types based on abundance (least first)

ntw.habitat.degr <- second.extinct(web = ntw.ANO.summed, nrep = 100, participant = "lower", method = "degree", details = FALSE) #random removal of nature types based on connections (most first)

#Plot these
slope.bipartite(ntw.habitat.rand, plot.it = TRUE)
slope.bipartite(ntw.habitat.abun, plot.it = TRUE)
slope.bipartite(ntw.habitat.degr, plot.it = TRUE)

```

#### Looping through multiple sites at once

Now we want to loop through several sites at once. For start, we can use the five sites we used earlier.

```{r}
#| eval: false

unique(df$site_id)

source("toolbox.R") #load code developed by Song et al. and available in his paper.
#let's loop through all sites
#first we create empty objects to store the data
sites <- unique(df$site_id)
ntwks <- list()
nested <- c()
NODF <- c()
st_NODF <- c()
rob_rand <- c()
rob_real <- c()
rich <- c()
seminat <- c()
for(i in 1:length(sites)){
  sitex <- subset(df, site_id == sites[i])
  #create the network in matrix format
  ntwx <- cast(sitex, patch_id ~ Species, fun.aggregate = "sum", 
               value = "Abundance")
  #we can remove first column with rownames
  ntwx <- ntwx[,-1]
  #let's visualize it with bipartite
  #plotweb(ntwx)
  ntwks[[i]] <- ntwx
  #calculate nestedness
  nested[i] <- networklevel(web = ntwx, index = "weighted NODF")
  rob_rand[i] <- robustness(second.extinct(web = ntwx, nrep = 50, participant = "lower", method = "random"))
  NODF[i] <- nestedness_NODF(as.matrix(ntwx))
  st_NODF[i] <- comb_nest(web = ntwx, NODF = NODF[i], max_NODF = max_nest(ntwx))
  #reate a realistic extinction sequence
  
  ext_seq <- unique(sitex[,c("Patch", "Habitat")])
  #quick and dirty way to order habitats
  levels(ext_seq$Habitat) <- c("gCorridor", "bForest",
                               "cForest_grassland_boundary",
                               "fMaintained_drain", 
                               "eMaintained_roadside",
                               "dNon_flowering_crop_edge",
                               "aSemi_natural_grasslands")
  ext_seq$Patch <- order(as.character(ext_seq$Habitat))
  rob_real[i] <- robustness(second.extinct(web = ntwx, participant = "lower", method = "external", ext.row = ext_seq$Patch )) #garsslands first, forest, etc...
  rich[i] <- ncol(ntwx)
  seminat[i] <- length(subset(ext_seq, Habitat %in%
                                c("aSemi_natural_grasslands",
                                  "bForest"))$Patch)
}
sites_measures <- data.frame(sites, nested, NODF, st_NODF, rob_rand, rob_real, rich, seminat)





```

```{r Create data matrix}
#Next step is to create a matrix file to do the network analyses

ANO.matrix


data.matrix(ANO.cover[], rownames.force = NA)



#we can remove the first column with rownames and create a matrix
#ANO_netw_ <- ANO.cover[,-1]
#ANO_netw <- as.matrix(ANO_netw_)
#colnames(ANO_netw) <- colnames(ANO_netw_)

ANO.matrix_ <- ANO.netw[,-1]
ANO.matrix <- as.matrix(ANO.matrix_)
colnames(ANO.matrix) <- colnames(ANO.matrix_)

#create the network in matrix format
ntwANO <- cast(site1, patch_id ~ Species, fun.aggregate = "mean", value = "species_cover")
#we can remove the first column with rownames
ntwANO_ <- ntwANO[,-1]
ntwANO <- as.matrix(ntwANO_)
colnames(ntwANO) <- colnames(ntwANO_)
#colnames(ntwANO) <- gsub(pattern = "Bombus_", replacement = "B. ", 
#                  x = colnames(ntwANO_), ignore.case = T)
#create a patch dataframe to store its properties.
#RR: original code for color doesn't work for all sites, as the number of habitats differs between them - needs a tidier solution, see below
patch <- unique(site1[, c("patch_id", "habitat_type")])
patch <- patch %>% 
  dplyr::group_by(habitat_type) %>% 
  dplyr::mutate(Color = randomcoloR::randomColor()) %>%
  dplyr::ungroup()

#patch$color <- c("gold", "green", "darkgreen", "orange", "lightgreen")
rownames(ntwANO) <- patch$patch_id
#create a vector of plants
plants <- cast(site1, Species ~ ., fun.aggregate = sum, value = "species_cover")
colnames(plants)[2] <- "cover"
plants$labs <- colnames(ntwANO)


```

Right now, the dataset is very large, and for the proof of concept, we can subset five ANO-flater (sites) that are in mountains. Here we just select the five first in the dataset: ANO0420, ANO0184, ANO0101, ANO0879, and ANO1455

```{r Subset data if needed}

#list <- c("ANO0420", "ANO0184", "ANO0289", "ANO0879", "ANO1455")

#df <- ANO.dat %>% 
#  filter(ano_flate_id %in% list)

```

We now want to convert this dataset to a long format.

```{r Convert to long format}

ANO.fjell.long <- pivot_longer(cols = `Festuca.ovina`:`Erigeron.acris`, 
    names_to = "Species",
    values_to = "species_cover")

```

More than one rute (plot) per flate (site) can have the same nature/habitat type. It is probably good to save this "resolution". Optionally, we can take the mean for each nature/habitat type within each flate (site). We then select one flate (site) to visualize a network.

```{r}
#| echo: false

df <- df %>%
  pivot_longer(cols = `Festuca.ovina`:`Erigeron.acris`, 
    names_to = "Species",
    values_to = "species_cover") %>%  #convert to long format
  dplyr::rename(habitat_type = kartleggingsenhet_1m2, 
                site_id = ano_flate_id, 
                patch_id = ano_punkt_id) %>% 
  filter(!is.na(species_cover)) %>% 
  filter(!(species_cover == 0))  #remove species without cover (one species was recorded without cover is the plot did not have any vascular vegetation)
#These lines can be used if we want to aggregate species cover across all similar nature types within a site (ANO-flate)
#  group_by(site_id, habitat_type, Species) %>% 
#  summarize(mean_cover = mean(species_cover, na.rm = FALSE))


#subset one site and the columns we need
site1 <- subset(df, site_id == "ANO0184")
site1

#create the network in matrix format
ntwANO <- cast(site1, patch_id ~ Species, fun.aggregate = "mean", value = "species_cover")
#we can remove the first column with rownames
ntwANO_ <- ntwANO[,-1]
ntwANO <- as.matrix(ntwANO_)
colnames(ntwANO) <- colnames(ntwANO_)
#colnames(ntwANO) <- gsub(pattern = "Bombus_", replacement = "B. ", 
#                  x = colnames(ntwANO_), ignore.case = T)
#create a patch dataframe to store its properties.
#RR: original code for color doesn't work for all sites, as the number of habitats differs between them - needs a tidier solution, see below
patch <- unique(site1[, c("patch_id", "habitat_type")])
patch <- patch %>% 
  dplyr::group_by(habitat_type) %>% 
  dplyr::mutate(Color = randomcoloR::randomColor()) %>%
  dplyr::ungroup()

#patch$color <- c("gold", "green", "darkgreen", "orange", "lightgreen")
rownames(ntwANO) <- patch$patch_id
#create a vector of plants
plants <- cast(site1, Species ~ ., fun.aggregate = sum, value = "species_cover")
colnames(plants)[2] <- "cover"
plants$labs <- colnames(ntwANO)

```

### Network visualization

```{r}

#We can use package _bipartite_ to plot it in two different ways:

#prepare legend
legend <- unique(patch[,c("habitat_type", "Color")])
par(xpd = T) #allow plotting outside the plot
plotweb(ntwANO, col.low = as.character(patch$Color))
legend(x=0, y=0.25, as.character(legend$habitat_type), pch=21,
       col="#777777", pt.bg=as.character(legend$Color), 
       pt.cex=1, cex=.6, bty="n", ncol=2)
visweb(ntwANO, prednames = T, preynames = T, labsize = 0.6)

#See also: https://briatte.github.io/ggnet/
```

```{r}
#or with pretier tools:
library(igraph)
#prepare the data for igraph
links <- site1[,c("Species", "patch_id", "species_cover")]
colnames(links)[3] <- "weight"
node1 <-  unique(site1[,c("patch_id", "habitat_type")])
colnames(node1) <- c("node", "attribute")
node1$type <- "habitat"
site1 <- as.data.frame(site1)
node2 <-  data.frame(node = unique(site1[,c("Species")]), 
                     attribute = NA,
                     type = "species")
nodes <- rbind(node1, node2)
#create igraph object
net <- graph_from_data_frame(d=links,
                             vertices=nodes, directed=F) 
# Generate colors based habitat: 
clrs <- data.frame(nod = V(net)$attribute,
                   cols = c(patch$Color, rep("blue",44 )))
V(net)$color <- as.character(clrs$cols)
# Compute node degrees (#links) and use that to set node size:
deg <- degree(net, mode="all")
V(net)$size <- deg*3
# Setting them to NA will render no labels:
#V(net)$label <- as.character(nodes$id) #RR: this throws an error
# Set edge width based on weight:
E(net)$width <- E(net)$weight/3
#change arrow size and edge color:
E(net)$arrow.size <- .2 #but note no arrows in Unidirected graphs like this
E(net)$edge.color <- "gray80"
#prepare colors
cl <- unique(clrs)
cl$nod <- as.character(cl$nod)
cl$nod[which(is.na(cl$nod))] <- "Species"
plot(net, vertex.label = NA) #force vertex label NA to make visualization clearer.
legend(x=-1.5, y=-1.1, cl$nod, pch=21,
       col="#777777", pt.bg=as.character(cl$cols), 
       pt.cex=2, cex=.8, bty="n", ncol=2) #RR: doesn't work
```

There is one more package *visNetwork* that makes impressive interactive plots that may be better to visualize and explore these kind of graphs.

```{r}
#| eval: false


colnames(nodes)[1] <- "id"
nodes$shape <- "dot"  
nodes$shadow <- TRUE # Nodes will drop shadow
nodes$attribute <- as.character(nodes$attribute) 
nodes$attribute[10:23] <-  as.character(nodes$id[10:23])#this is horrible coding
nodes$title <- nodes$attribute # Text on click
nodes$label <- nodes$type # Node label
nodes$size <- deg*3 # Node size
nodes$borderWidth <- 2 # Node border width

nodes$color.background <- clrs$cols
nodes$color.border <- "black"
nodes$color.highlight.background <- "orange"
nodes$color.highlight.border <- "darkred"
links$width <- links$weight # line width
links$color <- "gray"    # line color  
#links$arrows <- "middle" # arrows: 'from', 'to', or 'middle'
links$smooth <- TRUE    # should the edges be curved?
links$shadow <- FALSE    # edge shadow
colnames(links)[1:2] <- c("from", "to")
visNetwork(nodes, links) 
```

### Examine network structure

How is this network structured? To calculate it's *nestedness*, we use weighted NODF, one of the more popular and robust nestedness metrics (Almeida-Neto et al. 2008, Almeida-Neto et al. 2010), but other options are also available.

```{r}
(obs <- networklevel(web = ntwANO, index = "weighted NODF"))
```

To know if `r obs` is more nested than expected by chance for this network, we need to compare it with a null model:

```{r null, message=FALSE, warning=FALSE}
nm <- nullmodel(web = ntwANO, N=100, method="vaznull")
null <- unlist(sapply(nm, networklevel, index="weighted NODF")) 
plot(density(null), xlim=c(min(obs, min(null)), max(obs, max(null))), 
		main="comparison of observed with null model Patefield")
abline(v=obs, col="red", lwd=2)    
praw <- sum(null>obs) / length(null)

```

Here, we can see that this network is less nested than expected by chance (p value `r ifelse(praw > 0.5, round(1-praw,3), round(praw, 3))`). This suggests that these species do not use habitats in a nested way (i.e. species-rich habitats do not host species found in species poor habitats) and we should check for other network structural features.

To gain further insights on the structure of species habitats networks, we can use another important structural metric: modularity. In this example, we will calculate a quantitative version of the metric (Dormann et al., 2014).

For info on this: Detecting modules in quantitative bipartite networks: the QuaBiMo algorithm --Â arXiv Vanity (arxiv-vanity.com)

```{r}
#| fig.height: "160%"

res <- metaComputeModules(ntwANO, N = 5)
plotModuleWeb(res, displayAlabels = TRUE, displayBlabels = TRUE)

```

```{r}
#listModuleInformation(res)
#printoutModuleInformation(res)
modules.nulls <- sapply(nm, computeModules)
like.nulls <- sapply(modules.nulls, function(x) x@likelihood)
praw <- sum(like.nulls > res@likelihood) / length(like.nulls)
```

The network is more modular than expected by chance (p-value \< `r ifelse(praw > 0.5, round(1-praw,3), round(praw, 3))`). This confirms that each habitat tends to harbour a quite unique assemblage of species, with limited exchange between habitat patches. For the purpose of this worked example, we now focus on the description of these modules. We can see that patch 44, 51, 46, 24, 53, 62, 22, 66, etc...

```{r}
#we can calculate 2 values for each node
cz <- czvalues(res, weighted = TRUE, level = "lower")
#c : among-module connectivity
#z : within-module connectivity
#Olesen et al. (2006) give critical c and z values of 0.62 and 2.6, respectively. Species exceeding these values are deemed connectors or hubs of a network. The justification of these thresholds remains unclear to me. They may also not apply for the quantitative version.
plot(cz[[1]], cz[[2]], pch=16, xlab="c", ylab="z", 
     cex=0.8, las=1, col = patch$Color)
text(cz[[1]], cz[[2]], names(cz[[1]]), pos=4, cex=0.7)


#What does this mean?
```

Next, we can ask which habitat patches would we prioritize for its conservation value. For this we can calculate its strength (Bascopmte et al 2006).

```{r}
#we transpose the matrix to calculate it for the lower level.
patch$strength <- bipartite::strength(t(ntwANO), type="Bascompte")
patch

#produces NaN for strength??
```

### Looping through multiple sites at once

Now we want to loop through several sites at once. For start, we can use the five sites we used earlier.

```{r}
#| eval: false

unique(df$site_id)

source("toolbox.R") #load code developed by Song et al. and available in his paper.
#let's loop through all sites
#first we create empty objects to store the data
sites <- unique(df$site_id)
ntwks <- list()
nested <- c()
NODF <- c()
st_NODF <- c()
rob_rand <- c()
rob_real <- c()
rich <- c()
seminat <- c()
for(i in 1:length(sites)){
  sitex <- subset(df, site_id == sites[i])
  #create the network in matrix format
  ntwx <- cast(sitex, patch_id ~ Species, fun.aggregate = "sum", 
               value = "Abundance")
  #we can remove first column with rownames
  ntwx <- ntwx[,-1]
  #let's visualize it with bipartite
  #plotweb(ntwx)
  ntwks[[i]] <- ntwx
  #calculate nestedness
  nested[i] <- networklevel(web = ntwx, index = "weighted NODF")
  rob_rand[i] <- robustness(second.extinct(web = ntwx, nrep = 50, participant = "lower", method = "random"))
  NODF[i] <- nestedness_NODF(as.matrix(ntwx))
  st_NODF[i] <- comb_nest(web = ntwx, NODF = NODF[i], max_NODF = max_nest(ntwx))
  #reate a realistic extinction sequence
  
  ext_seq <- unique(sitex[,c("Patch", "Habitat")])
  #quick and dirty way to order habitats
  levels(ext_seq$Habitat) <- c("gCorridor", "bForest",
                               "cForest_grassland_boundary",
                               "fMaintained_drain", 
                               "eMaintained_roadside",
                               "dNon_flowering_crop_edge",
                               "aSemi_natural_grasslands")
  ext_seq$Patch <- order(as.character(ext_seq$Habitat))
  rob_real[i] <- robustness(second.extinct(web = ntwx, participant = "lower", method = "external", ext.row = ext_seq$Patch )) #garsslands first, forest, etc...
  rich[i] <- ncol(ntwx)
  seminat[i] <- length(subset(ext_seq, Habitat %in%
                                c("aSemi_natural_grasslands",
                                  "bForest"))$Patch)
}
sites_measures <- data.frame(sites, nested, NODF, st_NODF, rob_rand, rob_real, rich, seminat)





```

The `echo: false` option disables the printing of code (only output is displayed).

Calculate lots of things on the whole network

```{r}
networklevel(ntwANO)
```

Test Robustness (area of the area underneath the extinction curve) using random method (i.e. removing habitats randomly:

```{r}
ntw.ext.rand <- second.extinct(web = ntwANO, nrep = 100, participant = "lower", method = "random", details = FALSE)

ntw.ext.abun <- second.extinct(web = ntwANO, nrep = 50, participant = "lower", method = "abundance", details = FALSE)

ntw.ext.higher <- second.extinct(web = ntwANO, nrep = 100, participant = "higher", method = "abundance", details = FALSE)

#Calculate robustness (surface area underneath the extinction curve)
robustness(second.extinct(web = ntwANO, nrep = 50, participant = "lower", method = "abundance", details = TRUE))
```

Plot the extinction curve

```{r}
slope.bipartite(ntw.ext.rand, plot.it = TRUE)
slope.bipartite(ntw.ext.abun, plot.it = TRUE)
slope.bipartite(ntw.ext.higher, plot.it = TRUE)
```
